package util;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 * Utility math methods in addition to MathUtil but mainly focused on algebra.
 * 
 * @author Ashkan Moatamed
 */
public class AlgebraUtil {
	/**
	 * Dependencies: <code>
	 * 		1. util.NumUtil
	 * 		2. util.MathUtil
	 * 		3. util.InvalidModulusException
	 * </code>
	 */

	/**
	 * Prevent instantiation.
	 */
	private AlgebraUtil() {
		// Empty by design.
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Long, Long&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the elements of the cyclic group,
	 *            should be a <code>HashMap</code> instead of a <code>TreeMap</code>
	 * 
	 * @return The cyclic group generated by <code>n</code> modulo <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 * 
	 * @throws OutOfMemoryError
	 *             If <code>Integer.MAX_VALUE < order(n (mod m))</code>
	 */
	public static Map<Long, Long> cyclicGroup(long n, long m, boolean hash)
			throws InvalidModulusException, OutOfMemoryError {
		if (m < 2L) { // i.e., (m < 1) || (m == 1)
			if (m < 1L) {
				throw new InvalidModulusException();
			}
			// 1 <= m
			// i.e., m == 1
			// i.e., n == 0 (mod m)
			final Map<Long, Long> result = hash ? new HashMap<Long, Long>() : new TreeMap<Long, Long>();
			result.put(0L, 1L);
			return result;
		}
		// 2 <= m
		final Map<Long, Long> result = hash ? new HashMap<Long, Long>() : new TreeMap<Long, Long>();

		// Fix n to be in [0, m - 1] \cap \doubleZ.
		if ((n %= m) < 0L) {
			n += m;
		}

		// <code>n<sup>1</sup> (mod m) == n</code>.
		result.put(n, 1L);

		// Handle the simple special cases.
		if (n < 2L) { // i.e., (n == 0) || (n == 1)
			return result;
		}
		// 2 <= n
		// i.e., (1 < n) && (n <= m - 1) && (2 < m)
		if (n == m - 1L) { // i.e., n == -1 (mod m)
			result.put(1L, 2L);
			return result;
		}
		// n != m - 1
		// i.e., (1 < n) && (n < m - 1) && (3 < m)

		// Fix n to be in [-m / 2, m / 2] \cap \doubleZ.
		n = MathUtil.modMinFixedInput(n, m);

		// Fill and return the resulting map.
		Long index = null;
		for (long i = 2L, n_to_i = n, key = 0L; i != m; ++i) {
			// Update n_to_i and key.
			n_to_i = MathUtil.modMultFixedInput(n_to_i, n, m);
			/**
			 * Don't do <code>(n_to_i < 0L) ? (n_to_i += m) : n_to_i</code> since we want to maintain the
			 * following invariant <code>|n_to_i| <= (m / 2)</code>. Note that the difference is the
			 * <code>+=</code> instead of the <code>+</code> which will set <code>n_to_i</code> to
			 * <code>n_to_i (mod m)</code> which may violate the invariant.
			 */
			key = (n_to_i < 0L) ? (n_to_i + m) : n_to_i;

			// Update result.
			if ((index = result.put(key, i)) != null) { // order(n) == i - index
				// Re-map the current key to its original value.
				result.put(key, index);
				break;
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Long, Long&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.cyclicGroup(n, m, true)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 * 
	 * @throws OutOfMemoryError
	 *             If <code>Integer.MAX_VALUE < order(n (mod m))</code>
	 */
	public static Map<Long, Long> cyclicGroup(long n, long m) throws InvalidModulusException, OutOfMemoryError {
		return AlgebraUtil.cyclicGroup(n, m, true);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Integer, Integer&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the elements of the cyclic group,
	 *            should be a <code>HashMap</code> instead of a <code>TreeMap</code>
	 * 
	 * @return The cyclic group generated by <code>n</code> modulo <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static Map<Integer, Integer> cyclicGroup(int n, int m, boolean hash) throws InvalidModulusException {
		if (m < 2) { // i.e., (m < 1) || (m == 1)
			if (m < 1) {
				throw new InvalidModulusException();
			}
			// 1 <= m
			// i.e., m == 1
			// i.e., n == 0 (mod m)
			final Map<Integer, Integer> result = hash ? new HashMap<Integer, Integer>()
					: new TreeMap<Integer, Integer>();
			result.put(0, 1);
			return result;
		}
		// 2 <= m
		final Map<Integer, Integer> result = hash ? new HashMap<Integer, Integer>() : new TreeMap<Integer, Integer>();

		// Fix n to be in [0, m - 1] \cap \doubleZ.
		if ((n %= m) < 0) {
			n += m;
		}

		// <code>n<sup>1</sup> (mod m) == n</code>.
		result.put(n, 1);

		// Handle the simple special cases.
		if (n < 2) { // i.e., (n == 0) || (n == 1)
			return result;
		}
		// 2 <= n
		// i.e., (1 < n) && (n <= m - 1) && (2 < m)
		if (n == m - 1) { // i.e., n == -1 (mod m)
			result.put(1, 2);
			return result;
		}
		// n != m - 1
		// i.e., (1 < n) && (n < m - 1) && (3 < m)

		// Fix n to be in [-m / 2, m / 2] \cap \doubleZ.
		n = (int) MathUtil.modMinFixedInput(n, m);

		// Fill and return the resulting map.
		Integer index = null;
		for (int i = 2, n_to_i = n, key = 0; i != m; ++i) {
			// Update n_to_i and key.
			n_to_i = (int) MathUtil.modMultFixedInput(n_to_i, n, m);
			/**
			 * Don't do <code>(n_to_i < 0) ? (n_to_i += m) : n_to_i</code> since we want to maintain the
			 * following invariant <code>|n_to_i| <= (m / 2)</code>. Note that the difference is the
			 * <code>+=</code> instead of the <code>+</code> which will set <code>n_to_i</code> to
			 * <code>n_to_i (mod m)</code> which may violate the invariant.
			 */
			key = (n_to_i < 0) ? (n_to_i + m) : n_to_i;

			// Update result.
			if ((index = result.put(key, i)) != null) { // order(n) == i - index
				// Re-map the current key to its original value.
				result.put(key, index);
				break;
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Integer, Integer&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.cyclicGroup(n, m, true)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static Map<Integer, Integer> cyclicGroup(int n, int m) throws InvalidModulusException {
		return AlgebraUtil.cyclicGroup(n, m, true);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Short, Short&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the elements of the cyclic group,
	 *            should be a <code>HashMap</code> instead of a <code>TreeMap</code>
	 * 
	 * @return The cyclic group generated by <code>n</code> modulo <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static Map<Short, Short> cyclicGroup(short n, short m, boolean hash) throws InvalidModulusException {
		if (m < 2) { // i.e., (m < 1) || (m == 1)
			if (m < 1) {
				throw new InvalidModulusException();
			}
			// 1 <= m
			// i.e., m == 1
			// i.e., n == 0 (mod m)
			final Map<Short, Short> result = hash ? new HashMap<Short, Short>() : new TreeMap<Short, Short>();
			result.put((short) 0, (short) 1);
			return result;
		}
		// 2 <= m
		final Map<Short, Short> result = hash ? new HashMap<Short, Short>() : new TreeMap<Short, Short>();

		// Fix n to be in [0, m - 1] \cap \doubleZ.
		if ((n %= m) < 0) {
			n += m;
		}

		// <code>n<sup>1</sup> (mod m) == n</code>.
		result.put(n, (short) 1);

		// Handle the simple special cases.
		if (n < 2) { // i.e., (n == 0) || (n == 1)
			return result;
		}
		// 2 <= n
		// i.e., (1 < n) && (n <= m - 1) && (2 < m)
		if (n == m - 1) { // i.e., n == -1 (mod m)
			result.put((short) 1, (short) 2);
			return result;
		}
		// n != m - 1
		// i.e., (1 < n) && (n < m - 1) && (3 < m)

		// Fix n to be in [-m / 2, m / 2] \cap \doubleZ.
		n = (short) MathUtil.modMinFixedInput(n, m);

		// Fill and return the resulting map.
		Short index = null;
		for (short i = 2, n_to_i = n, key = 0; i != m; ++i) {
			// Update n_to_i and key.
			n_to_i = (short) MathUtil.modMultFixedInput(n_to_i, n, m);
			/**
			 * Don't do <code>(n_to_i < 0) ? (n_to_i += m) : n_to_i</code> since we want to maintain the
			 * following invariant <code>|n_to_i| <= (m / 2)</code>. Note that the difference is the
			 * <code>+=</code> instead of the <code>+</code> which will set <code>n_to_i</code> to
			 * <code>n_to_i (mod m)</code> which may violate the invariant.
			 */
			key = (short) ((n_to_i < 0) ? (n_to_i + m) : n_to_i);

			// Update result.
			if ((index = result.put(key, i)) != null) { // order(n) == i - index
				// Re-map the current key to its original value.
				result.put(key, index);
				break;
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Short, Short&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.cyclicGroup(n, m, true)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static Map<Short, Short> cyclicGroup(short n, short m) throws InvalidModulusException {
		return AlgebraUtil.cyclicGroup(n, m, true);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Byte, Byte&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the elements of the cyclic group,
	 *            should be a <code>HashMap</code> instead of a <code>TreeMap</code>
	 * 
	 * @return The cyclic group generated by <code>n</code> modulo <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static Map<Byte, Byte> cyclicGroup(byte n, byte m, boolean hash) throws InvalidModulusException {
		if (m < 2) { // i.e., (m < 1) || (m == 1)
			if (m < 1) {
				throw new InvalidModulusException();
			}
			// 1 <= m
			// i.e., m == 1
			// i.e., n == 0 (mod m)
			final Map<Byte, Byte> result = hash ? new HashMap<Byte, Byte>() : new TreeMap<Byte, Byte>();
			result.put((byte) 0, (byte) 1);
			return result;
		}
		// 2 <= m
		final Map<Byte, Byte> result = hash ? new HashMap<Byte, Byte>() : new TreeMap<Byte, Byte>();

		// Fix n to be in [0, m - 1] \cap \doubleZ.
		if ((n %= m) < 0) {
			n += m;
		}

		// <code>n<sup>1</sup> (mod m) == n</code>.
		result.put(n, (byte) 1);

		// Handle the simple special cases.
		if (n < 2) { // i.e., (n == 0) || (n == 1)
			return result;
		}
		// 2 <= n
		// i.e., (1 < n) && (n <= m - 1) && (2 < m)
		if (n == m - 1) { // i.e., n == -1 (mod m)
			result.put((byte) 1, (byte) 2);
			return result;
		}
		// n != m - 1
		// i.e., (1 < n) && (n < m - 1) && (3 < m)

		// Fix n to be in [-m / 2, m / 2] \cap \doubleZ.
		n = (byte) MathUtil.modMinFixedInput(n, m);

		// Fill and return the resulting map.
		Byte index = null;
		for (byte i = 2, n_to_i = n, key = 0; i != m; ++i) {
			// Update n_to_i and key.
			n_to_i = (byte) MathUtil.modMultFixedInput(n_to_i, n, m);
			/**
			 * Don't do <code>(n_to_i < 0) ? (n_to_i += m) : n_to_i</code> since we want to maintain the
			 * following invariant <code>|n_to_i| <= (m / 2)</code>. Note that the difference is the
			 * <code>+=</code> instead of the <code>+</code> which will set <code>n_to_i</code> to
			 * <code>n_to_i (mod m)</code> which may violate the invariant.
			 */
			key = (byte) ((n_to_i < 0) ? (n_to_i + m) : n_to_i);

			// Update result.
			if ((index = result.put(key, i)) != null) { // order(n) == i - index
				// Re-map the current key to its original value.
				result.put(key, index);
				break;
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(0 < Result.size()) && (Result.size() < m)</code> <br>
	 * Postcondition:
	 * 
	 * <pre>
	 * <code>
	 * for (final Map.Entry&lt;Byte, Byte&gt; entry : Result.entrySet()) {
	 * 	assert ((entry.getValue() != null) && (0 < entry.getValue()) && (entry.getValue() < m));
	 * 	assert ((entry.getKey() != null) && (entry.getKey() == MathUtil.modPow(n, entry.getValue(), m)));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.cyclicGroup(n, m, true)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static Map<Byte, Byte> cyclicGroup(byte n, byte m) throws InvalidModulusException {
		return AlgebraUtil.cyclicGroup(n, m, true);
	}

	/**
	 * Precondition: <code>7 <= m</code> <br>
	 * Precondition: <code>(m % 2 != 0) || ((m / 2) % 2 != 0)</code> <br>
	 * Precondition: <code>NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1</code> <br>
	 * Precondition: <code>(1 < n) && (n < m - 1)</code> <br>
	 * Precondition: <code>gcd(n, m) == 1</code> <br>
	 * Precondition: <code>(phiMFactorsKeySet != null) && (!phiMFactorsKeySet.isEmpty())</code> <br>
	 * Precondition:
	 * 
	 * <pre>
	 * <code>
	 * final Map&lt;Long, Byte&gt; factors = NumUtil.factorSqrt(phiM);
	 * assert (phiMFactorsKeySet.size() == factors.size());
	 * for (final Long q : phiMFactorsKeySet) {
	 * 	assert ((q != null) && factors.containsKey(q));
	 * }
	 * </code>
	 * </pre>
	 * 
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param phiM
	 *            <code>phi(m)</code>
	 * 
	 * @param phiMFactorsKeySet
	 *            the given set containing the (distinct) prime divisors of <code>phiM</code>
	 * 
	 * @return <code>true</code> if and only if <code>n</code> is a primitive root modulo
	 *         <code>m</code>.
	 */
	protected static boolean isPrimitiveRootFixedInput(long n, long m, long phiM, Set<Long> phiMFactorsKeySet) {
		/**
		 * We know that <code>!phiMFactorsKeySet.isEmpty()</code> and so we can optimize the following loop
		 * by removing an extra call to <code>it.hashNext()</code> by writing it as a do-while loop instead
		 * of a for loop or a while loop.
		 */
		final Iterator<Long> it = phiMFactorsKeySet.iterator();
		do {
			/**
			 * We know that for <code>n</code> in <code>[2, m - 2] \cap \doubleZ</code> coprime with
			 * <code>m</code>, <code>n</code> is a primitive root modulo <code>m</code> if and only if
			 * <code>n<sup>(<sup>phi(m)</sup>&frasl;<sub>q</sub>)</sup> (mod m) != 1</code> for all
			 * <code>q</code> where <code>q</code> is a prime divisor of <code>phi(m)</code>.
			 */
			if (MathUtil.modPowFixedInput(n, phiM / it.next(), m) == 1L) {
				/**
				 * Note that <code>MathUtil.modMinFixedInput</code> (and as a result
				 * <code>MathUtil.modPowFixedInput</code>) return <code>1</code> instead of <code>1 - m</code> for
				 * all <code>1 < m</code> so the check is fine and we do not need to fix the result of
				 * <code>MathUtil.modPowFixedInput</code> to be in <code>[0, m - 1] \cap \doubleZ</code> by adding
				 * <code>m</code> to it if it's negative.
				 */
				return false;
			}
		} while (it.hasNext());
		return true;
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return <code>true</code> if and only if <code>n</code> is a primitive root modulo
	 *         <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(long n, long m, boolean hash, boolean print) throws InvalidModulusException {
		if (m < 7L) { // i.e., (m < 1) || (m == 1) || (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m < 1L) {
				throw new InvalidModulusException();
			} else if (m == 1L) { // i.e., n == 0 (mod m)
				return false;
			}
			// 1 < m
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)

			// Fix n to be in [0, m - 1] \cap \doubleZ.
			if ((n %= m) < 0L) {
				n += m;
			}
			// Handle the <code>n == 0</code> case.
			if (n == 0L) {
				return false;
			}
			// n != 0
			// i.e., (1 <= n) && (n <= m - 1)

			// Handle the simple special cases.
			if (m == 5L) {
				return ((n == 2L) || (n == 3L)); // Only primitive roots mod 5, are 2 and 3.
			}
			// m != 5
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 6)
			/**
			 * It's fine to do <code>++n</code> instead of <code>n + 1</code> since we don't need the value of
			 * <code>n</code> to remain unchanged.
			 */
			return (++n == m); // Only primitive root mod m, is m - 1 for m in { 2, 3, 4, 6 }.
		}
		// 7 <= m

		/**
		 * There is a primitive root mod <code>m</code>, if and only if <code>m</code> factors into
		 * <code>p<sup>e</sup></code> or <code>2 * p<sup>e</sup></code> where <code>p</code> is an odd prime
		 * number and <code>e</code> is a natural number. Therefore, make sure that <code>2</code> divides
		 * <code>m</code> at most once.
		 */
		long mOddFactor = m;
		if ((mOddFactor & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
			/**
			 * Don't do <code>(mOddFactor &= 1L) == 0L</code> since we need the value of <code>mOddFactor</code>
			 * to remain unchanged. Note that the difference is the <code>&=</code> instead of the
			 * <code>&</code> which will mutate <code>mOddFactor</code>. <br>
			 * <br>
			 * 
			 * However, the following is meant to be an assignment of <code>mOddFactor</code> when we do
			 * <code>mOddFactor /= 2L</code> instead of <code>mOddFactor / 2L</code>.
			 */
			if (((mOddFactor /= 2L) & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
				return false; // There are no primitive roots mod m since m % 4 == 0.
			}
		}
		// ((m % 2 != 0) && (mOddFactor == m)) || (((m / 2) % 2 != 0) && (mOddFactor == m / 2))

		// Fix n to be in [0, m - 1] \cap \doubleZ.
		if ((n %= m) < 0L) {
			n += m;
		}

		/**
		 * For all <code>7 <= m</code>, we know that <code>0</code>, <code>1</code>, and <code>m - 1</code>
		 * can never be a primitive root modulo <code>m</code> since <code>3 <= phi(m)</code> but
		 * <code>order(0) DNE</code>, <code>order(1) == 1</code>, and <code>order(m - 1) == 2</code>.
		 */
		if ((n < 2L) || (n == m - 1L)) { // i.e., (n == 0) || (n == 1) || (n == -1 (mod m))
			return false;
		}
		// (2 <= n) && (n <= m - 2)
		// i.e., (1 < n) && (n < m - 1)

		/**
		 * We know that a primitive root modulo <code>m</code>, must be coprime with <code>m</code>.
		 */
		if (MathUtil.gcdFixedInput(n, m) != 1L) {
			return false;
		}
		// gcd(n, m) == 1

		/**
		 * Factor the largest odd divisor of <code>m</code> and check whether it is a prime power.
		 */
		final Map<Long, Byte> mOddFactors = NumUtil.factorSqrt(mOddFactor, hash, false);
		// Only print if requested.
		if (print) {
			if (m == mOddFactor) {
				System.out.print("m = " + m + " = ");
			} else { // m != mOddFactor
				// i.e., m == 2 * mOddFactor
				System.out.print("m = " + m + " = 2 * ");
			}
			NumUtil.printFactorsLong(mOddFactors, hash);
		}
		if (mOddFactors.size() != 1) {
			return false; // There are no primitive roots mod m since mOddFactor isn't a prime power.
		}

		/**
		 * Compute <code>phi(m)</code> and then factor it. <br>
		 * <br>
		 * 
		 * At this point, we know that one of the following is true: <br>
		 * Case I: <code>m == mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(mOddFactor)</code> <br>
		 * Case II: <code>m == 2 * mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(2) * phi(mOddFactor) == 1 * phi(mOddFactor)</code> <br>
		 * <br>
		 * 
		 * However, we also know that <code>mOddFactor == p<sup>e</sup></code> and so we can conclude that
		 * <code>phi(m) == phi(mOddFactor) == mOddFactor * (1 - <sup>1</sup>&frasl;<sub>p</sub>)</code>.
		 */
		final long p = mOddFactors.entrySet().iterator().next().getKey();
		final long phiM = mOddFactor - (mOddFactor / p);
		final Map<Long, Byte> phiMFactors = NumUtil.factorSqrt(phiM, hash, false);
		// Only print if requested.
		if (print) {
			System.out.print("phi(m) = " + phiM + " = ");
			NumUtil.printFactorsLong(phiMFactors, hash);
		}
		final Set<Long> phiMFactorsKeySet = phiMFactors.keySet();
		return AlgebraUtil.isPrimitiveRootFixedInput(n, m, phiM, phiMFactorsKeySet);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(long n, long m, boolean hash) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, hash, false);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(long n, long m) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, false);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return <code>true</code> if and only if <code>n</code> is a primitive root modulo
	 *         <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(int n, int m, boolean hash, boolean print) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot((long) n, (long) m, hash, print);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(int n, int m, boolean hash) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, hash, false);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(int n, int m) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, false);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return <code>true</code> if and only if <code>n</code> is a primitive root modulo
	 *         <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(short n, short m, boolean hash, boolean print)
			throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot((long) n, (long) m, hash, print);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(short n, short m, boolean hash) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, hash, false);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(short n, short m) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, false);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return <code>true</code> if and only if <code>n</code> is a primitive root modulo
	 *         <code>m</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(byte n, byte m, boolean hash, boolean print) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot((long) n, (long) m, hash, print);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(byte n, byte m, boolean hash) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, hash, false);
	}

	/**
	 * @param n
	 *            the given number
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.isPrimitiveRoot(n, m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static boolean isPrimitiveRoot(byte n, byte m) throws InvalidModulusException {
		return AlgebraUtil.isPrimitiveRoot(n, m, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return The resulting long array.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 * 
	 * @throws OutOfMemoryError
	 *             If <code>Integer.MAX_VALUE < phi(phi(m))</code>
	 */
	public static long[] primitiveRoots(long m, boolean hash, boolean print)
			throws InvalidModulusException, OutOfMemoryError {
		if (m < 7L) { // i.e., (m < 1) || (m == 1) || (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m < 1L) {
				throw new InvalidModulusException();
			} else if (m == 1L) {
				return new long[] {}; // There are no primitive roots mod 1.
			}
			// 1 < m
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m == 5L) {
				return new long[] { 2L, 3L }; // Only primitive roots mod 5, are 2 and 3.
			}
			// m != 5
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 6)
			/**
			 * It's fine to do <code>--m</code> instead of <code>m - 1</code> since we don't need the value of
			 * <code>m</code> to remain unchanged.
			 */
			return new long[] { --m }; // Only primitive root mod m, is m - 1 for m in { 2, 3, 4, 6 }.
		}
		// 7 <= m

		/**
		 * There is a primitive root mod <code>m</code>, if and only if <code>m</code> factors into
		 * <code>p<sup>e</sup></code> or <code>2 * p<sup>e</sup></code> where <code>p</code> is an odd prime
		 * number and <code>e</code> is a natural number. Therefore, make sure that <code>2</code> divides
		 * <code>m</code> at most once.
		 */
		long mOddFactor = m;
		if ((mOddFactor & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
			/**
			 * Don't do <code>(mOddFactor &= 1L) == 0L</code> since we need the value of <code>mOddFactor</code>
			 * to remain unchanged. Note that the difference is the <code>&=</code> instead of the
			 * <code>&</code> which will mutate <code>mOddFactor</code>. <br>
			 * <br>
			 * 
			 * However, the following is meant to be an assignment of <code>mOddFactor</code> when we do
			 * <code>mOddFactor /= 2L</code> instead of <code>mOddFactor / 2L</code>.
			 */
			if (((mOddFactor /= 2L) & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
				return new long[] {}; // There are no primitive roots mod m since m % 4 == 0.
			}
		}
		// ((m % 2 != 0) && (mOddFactor == m)) || (((m / 2) % 2 != 0) && (mOddFactor == m / 2))

		/**
		 * Factor the largest odd divisor of <code>m</code> and check whether it is a prime power.
		 */
		final Map<Long, Byte> mOddFactors = NumUtil.factorSqrt(mOddFactor, hash, false);
		// Only print if requested.
		if (print) {
			if (m == mOddFactor) {
				System.out.print("m = " + m + " = ");
			} else { // m != mOddFactor
				// i.e., m == 2 * mOddFactor
				System.out.print("m = " + m + " = 2 * ");
			}
			NumUtil.printFactorsLong(mOddFactors, hash);
		}
		if (mOddFactors.size() != 1) {
			return new long[] {}; // There are no primitive roots mod m since mOddFactor isn't a prime power.
		}

		/**
		 * Compute <code>phi(m)</code> and then factor it. <br>
		 * <br>
		 * 
		 * At this point, we know that one of the following is true: <br>
		 * Case I: <code>m == mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(mOddFactor)</code> <br>
		 * Case II: <code>m == 2 * mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(2) * phi(mOddFactor) == 1 * phi(mOddFactor)</code> <br>
		 * <br>
		 * 
		 * However, we also know that <code>mOddFactor == p<sup>e</sup></code> and so we can conclude that
		 * <code>phi(m) == phi(mOddFactor) == mOddFactor * (1 - <sup>1</sup>&frasl;<sub>p</sub>)</code>.
		 */
		final long p = mOddFactors.entrySet().iterator().next().getKey();
		final long phiM = mOddFactor - (mOddFactor / p);
		final Map<Long, Byte> phiMFactors = NumUtil.factorSqrt(phiM, hash, false);
		// Only print if requested.
		if (print) {
			System.out.print("phi(m) = " + phiM + " = ");
			NumUtil.printFactorsLong(phiMFactors, hash);
		}
		final Set<Long> phiMFactorsKeySet = phiMFactors.keySet();

		/**
		 * Compute <code>phi(phi(m))</code> which is the number of primitive roots mod <code>m</code> using
		 * the following fact: <br>
		 * <br>
		 * 
		 * We know that
		 * <code>phi(n) = product(phi(p<sub>i</sub><sup>e<sub>i</sub></sup>) from i = 1 to i = t)</code>
		 * where <code>p<sub>i</sub></code>'s are the prime factors of <code>n</code> with natural powers
		 * <code>e<sub>i</sub></code> and natural number <code>t</code>. After a little bit of
		 * simplification, we can find that
		 * <code>phi(n) = n * product((1 - <sup>1</sup>&frasl;<sub>p<sub>i</sub></sub>) from i = 1 to i = t)</code>.
		 */
		long phiPhiM = phiM;
		final Iterator<Long> it = phiMFactorsKeySet.iterator();
		do {
			phiPhiM -= (phiPhiM / it.next());
		} while (it.hasNext());

		// Create, fill, and return the resulting long array.
		if (Integer.MAX_VALUE < phiPhiM) {
			throw new OutOfMemoryError();
		}
		// phi(phi(m)) <= Integer.MAX_VALUE
		final long[] result = new long[(int) phiPhiM];
		int index = 0;
		final long maxN = m - 1L;
		if (m == mOddFactor) { // i.e., m % 2 != 0
			for (long n = 2L; n != maxN; ++n) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, m, phiM, phiMFactorsKeySet)) {
						result[index] = n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		} else { // i.e., m % 2 == 0
			for (long n = 3L; n != maxN; n += 2L) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, m, phiM, phiMFactorsKeySet)) {
						result[index] = n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 * 
	 * @throws OutOfMemoryError
	 *             If <code>Integer.MAX_VALUE < phi(phi(m))</code>
	 */
	public static long[] primitiveRoots(long m, boolean hash) throws InvalidModulusException, OutOfMemoryError {
		return AlgebraUtil.primitiveRoots(m, hash, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 * 
	 * @throws OutOfMemoryError
	 *             If <code>Integer.MAX_VALUE < phi(phi(m))</code>
	 */
	public static long[] primitiveRoots(long m) throws InvalidModulusException, OutOfMemoryError {
		return AlgebraUtil.primitiveRoots(m, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return The resulting integer array.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static int[] primitiveRoots(int m, boolean hash, boolean print) throws InvalidModulusException {
		if (m < 7) { // i.e., (m < 1) || (m == 1) || (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m < 1) {
				throw new InvalidModulusException();
			} else if (m == 1) {
				return new int[] {}; // There are no primitive roots mod 1.
			}
			// 1 < m
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m == 5) {
				return new int[] { 2, 3 }; // Only primitive roots mod 5, are 2 and 3.
			}
			// m != 5
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 6)
			/**
			 * It's fine to do <code>--m</code> instead of <code>m - 1</code> since we don't need the value of
			 * <code>m</code> to remain unchanged.
			 */
			return new int[] { --m }; // Only primitive root mod m, is m - 1 for m in { 2, 3, 4, 6 }.
		}
		// 7 <= m

		/**
		 * Use <code>long</code> type (instead of <code>int</code>) in all of the following computations
		 * since <code>AlgebraUtil.isPrimitiveRootFixedInput</code> takes a <code>Set&lt;Long&gt;</code> as
		 * its last argument.
		 */

		/**
		 * There is a primitive root mod <code>m</code>, if and only if <code>m</code> factors into
		 * <code>p<sup>e</sup></code> or <code>2 * p<sup>e</sup></code> where <code>p</code> is an odd prime
		 * number and <code>e</code> is a natural number. Therefore, make sure that <code>2</code> divides
		 * <code>m</code> at most once.
		 */
		long mOddFactor = m;
		if ((mOddFactor & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
			/**
			 * Don't do <code>(mOddFactor &= 1L) == 0L</code> since we need the value of <code>mOddFactor</code>
			 * to remain unchanged. Note that the difference is the <code>&=</code> instead of the
			 * <code>&</code> which will mutate <code>mOddFactor</code>. <br>
			 * <br>
			 * 
			 * However, the following is meant to be an assignment of <code>mOddFactor</code> when we do
			 * <code>mOddFactor /= 2L</code> instead of <code>mOddFactor / 2L</code>.
			 */
			if (((mOddFactor /= 2L) & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
				return new int[] {}; // There are no primitive roots mod m since m % 4 == 0.
			}
		}
		// ((m % 2 != 0) && (mOddFactor == m)) || (((m / 2) % 2 != 0) && (mOddFactor == m / 2))

		/**
		 * Factor the largest odd divisor of <code>m</code> and check whether it is a prime power.
		 */
		final Map<Long, Byte> mOddFactors = NumUtil.factorSqrt(mOddFactor, hash, false);
		// Only print if requested.
		if (print) {
			if (m == mOddFactor) {
				System.out.print("m = " + m + " = ");
			} else { // m != mOddFactor
				// i.e., m == 2 * mOddFactor
				System.out.print("m = " + m + " = 2 * ");
			}
			NumUtil.printFactorsLong(mOddFactors, hash);
		}
		if (mOddFactors.size() != 1) {
			return new int[] {}; // There are no primitive roots mod m since mOddFactor isn't a prime power.
		}

		/**
		 * Compute <code>phi(m)</code> and then factor it. <br>
		 * <br>
		 * 
		 * At this point, we know that one of the following is true: <br>
		 * Case I: <code>m == mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(mOddFactor)</code> <br>
		 * Case II: <code>m == 2 * mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(2) * phi(mOddFactor) == 1 * phi(mOddFactor)</code> <br>
		 * <br>
		 * 
		 * However, we also know that <code>mOddFactor == p<sup>e</sup></code> and so we can conclude that
		 * <code>phi(m) == phi(mOddFactor) == mOddFactor * (1 - <sup>1</sup>&frasl;<sub>p</sub>)</code>.
		 */
		final long p = mOddFactors.entrySet().iterator().next().getKey();
		final long phiM = mOddFactor - (mOddFactor / p);
		final Map<Long, Byte> phiMFactors = NumUtil.factorSqrt(phiM, hash, false);
		// Only print if requested.
		if (print) {
			System.out.print("phi(m) = " + phiM + " = ");
			NumUtil.printFactorsLong(phiMFactors, hash);
		}
		final Set<Long> phiMFactorsKeySet = phiMFactors.keySet();

		/**
		 * Compute <code>phi(phi(m))</code> which is the number of primitive roots mod <code>m</code> using
		 * the following fact: <br>
		 * <br>
		 * 
		 * We know that
		 * <code>phi(n) = product(phi(p<sub>i</sub><sup>e<sub>i</sub></sup>) from i = 1 to i = t)</code>
		 * where <code>p<sub>i</sub></code>'s are the prime factors of <code>n</code> with natural powers
		 * <code>e<sub>i</sub></code> and natural number <code>t</code>. After a little bit of
		 * simplification, we can find that
		 * <code>phi(n) = n * product((1 - <sup>1</sup>&frasl;<sub>p<sub>i</sub></sub>) from i = 1 to i = t)</code>.
		 */
		long phiPhiM = phiM;
		final Iterator<Long> it = phiMFactorsKeySet.iterator();
		do {
			phiPhiM -= (phiPhiM / it.next());
		} while (it.hasNext());

		// Create, fill, and return the resulting integer array.
		final int[] result = new int[(int) phiPhiM];
		int index = 0;
		// Save m as a long to avoid the upcast in every iteration of the loop.
		final long M = m, maxN = M - 1L;
		if (M == mOddFactor) { // i.e., m % 2 != 0
			for (long n = 2L; n != maxN; ++n) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, M, phiM, phiMFactorsKeySet)) {
						result[index] = (int) n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		} else { // i.e., m % 2 == 0
			for (long n = 3L; n != maxN; n += 2L) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, M, phiM, phiMFactorsKeySet)) {
						result[index] = (int) n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static int[] primitiveRoots(int m, boolean hash) throws InvalidModulusException {
		return AlgebraUtil.primitiveRoots(m, hash, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static int[] primitiveRoots(int m) throws InvalidModulusException {
		return AlgebraUtil.primitiveRoots(m, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return The resulting short array.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static short[] primitiveRoots(short m, boolean hash, boolean print) throws InvalidModulusException {
		if (m < 7) { // i.e., (m < 1) || (m == 1) || (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m < 1) {
				throw new InvalidModulusException();
			} else if (m == 1) {
				return new short[] {}; // There are no primitive roots mod 1.
			}
			// 1 < m
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m == 5) {
				return new short[] { 2, 3 }; // Only primitive roots mod 5, are 2 and 3.
			}
			// m != 5
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 6)
			/**
			 * It's fine to do <code>--m</code> instead of <code>m - 1</code> since we don't need the value of
			 * <code>m</code> to remain unchanged.
			 */
			return new short[] { --m }; // Only primitive root mod m, is m - 1 for m in { 2, 3, 4, 6 }.
		}
		// 7 <= m

		/**
		 * Use <code>long</code> type (instead of <code>short</code>) in all of the following computations
		 * since <code>AlgebraUtil.isPrimitiveRootFixedInput</code> takes a <code>Set&lt;Long&gt;</code> as
		 * its last argument.
		 */

		/**
		 * There is a primitive root mod <code>m</code>, if and only if <code>m</code> factors into
		 * <code>p<sup>e</sup></code> or <code>2 * p<sup>e</sup></code> where <code>p</code> is an odd prime
		 * number and <code>e</code> is a natural number. Therefore, make sure that <code>2</code> divides
		 * <code>m</code> at most once.
		 */
		long mOddFactor = m;
		if ((mOddFactor & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
			/**
			 * Don't do <code>(mOddFactor &= 1L) == 0L</code> since we need the value of <code>mOddFactor</code>
			 * to remain unchanged. Note that the difference is the <code>&=</code> instead of the
			 * <code>&</code> which will mutate <code>mOddFactor</code>. <br>
			 * <br>
			 * 
			 * However, the following is meant to be an assignment of <code>mOddFactor</code> when we do
			 * <code>mOddFactor /= 2L</code> instead of <code>mOddFactor / 2L</code>.
			 */
			if (((mOddFactor /= 2L) & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
				return new short[] {}; // There are no primitive roots mod m since m % 4 == 0.
			}
		}
		// ((m % 2 != 0) && (mOddFactor == m)) || (((m / 2) % 2 != 0) && (mOddFactor == m / 2))

		/**
		 * Factor the largest odd divisor of <code>m</code> and check whether it is a prime power.
		 */
		final Map<Long, Byte> mOddFactors = NumUtil.factorSqrt(mOddFactor, hash, false);
		// Only print if requested.
		if (print) {
			if (m == mOddFactor) {
				System.out.print("m = " + m + " = ");
			} else { // m != mOddFactor
				// i.e., m == 2 * mOddFactor
				System.out.print("m = " + m + " = 2 * ");
			}
			NumUtil.printFactorsLong(mOddFactors, hash);
		}
		if (mOddFactors.size() != 1) {
			return new short[] {}; // There are no primitive roots mod m since mOddFactor isn't a prime power.
		}

		/**
		 * Compute <code>phi(m)</code> and then factor it. <br>
		 * <br>
		 * 
		 * At this point, we know that one of the following is true: <br>
		 * Case I: <code>m == mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(mOddFactor)</code> <br>
		 * Case II: <code>m == 2 * mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(2) * phi(mOddFactor) == 1 * phi(mOddFactor)</code> <br>
		 * <br>
		 * 
		 * However, we also know that <code>mOddFactor == p<sup>e</sup></code> and so we can conclude that
		 * <code>phi(m) == phi(mOddFactor) == mOddFactor * (1 - <sup>1</sup>&frasl;<sub>p</sub>)</code>.
		 */
		final long p = mOddFactors.entrySet().iterator().next().getKey();
		final long phiM = mOddFactor - (mOddFactor / p);
		final Map<Long, Byte> phiMFactors = NumUtil.factorSqrt(phiM, hash, false);
		// Only print if requested.
		if (print) {
			System.out.print("phi(m) = " + phiM + " = ");
			NumUtil.printFactorsLong(phiMFactors, hash);
		}
		final Set<Long> phiMFactorsKeySet = phiMFactors.keySet();

		/**
		 * Compute <code>phi(phi(m))</code> which is the number of primitive roots mod <code>m</code> using
		 * the following fact: <br>
		 * <br>
		 * 
		 * We know that
		 * <code>phi(n) = product(phi(p<sub>i</sub><sup>e<sub>i</sub></sup>) from i = 1 to i = t)</code>
		 * where <code>p<sub>i</sub></code>'s are the prime factors of <code>n</code> with natural powers
		 * <code>e<sub>i</sub></code> and natural number <code>t</code>. After a little bit of
		 * simplification, we can find that
		 * <code>phi(n) = n * product((1 - <sup>1</sup>&frasl;<sub>p<sub>i</sub></sub>) from i = 1 to i = t)</code>.
		 */
		long phiPhiM = phiM;
		final Iterator<Long> it = phiMFactorsKeySet.iterator();
		do {
			phiPhiM -= (phiPhiM / it.next());
		} while (it.hasNext());

		// Create, fill, and return the resulting short array.
		final short[] result = new short[(int) phiPhiM];
		int index = 0;
		// Save m as a long to avoid the upcast in every iteration of the loop.
		final long M = m, maxN = M - 1L;
		if (M == mOddFactor) { // i.e., m % 2 != 0
			for (long n = 2L; n != maxN; ++n) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, M, phiM, phiMFactorsKeySet)) {
						result[index] = (short) n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		} else { // i.e., m % 2 == 0
			for (long n = 3L; n != maxN; n += 2L) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, M, phiM, phiMFactorsKeySet)) {
						result[index] = (short) n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static short[] primitiveRoots(short m, boolean hash) throws InvalidModulusException {
		return AlgebraUtil.primitiveRoots(m, hash, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static short[] primitiveRoots(short m) throws InvalidModulusException {
		return AlgebraUtil.primitiveRoots(m, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @param print
	 *            specifies whether the factoring of <code>m</code> and <code>phi(m)</code> should be
	 *            printed to the standard output stream
	 * 
	 * @return The resulting byte array.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static byte[] primitiveRoots(byte m, boolean hash, boolean print) throws InvalidModulusException {
		if (m < 7) { // i.e., (m < 1) || (m == 1) || (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m < 1) {
				throw new InvalidModulusException();
			} else if (m == 1) {
				return new byte[] {}; // There are no primitive roots mod 1.
			}
			// 1 < m
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 5) || (m == 6)
			if (m == 5) {
				return new byte[] { 2, 3 }; // Only primitive roots mod 5, are 2 and 3.
			}
			// m != 5
			// i.e., (m == 2) || (m == 3) || (m == 4) || (m == 6)
			/**
			 * It's fine to do <code>--m</code> instead of <code>m - 1</code> since we don't need the value of
			 * <code>m</code> to remain unchanged.
			 */
			return new byte[] { --m }; // Only primitive root mod m, is m - 1 for m in { 2, 3, 4, 6 }.
		}
		// 7 <= m

		/**
		 * Use <code>long</code> type (instead of <code>byte</code>) in all of the following computations
		 * since <code>AlgebraUtil.isPrimitiveRootFixedInput</code> takes a <code>Set&lt;Long&gt;</code> as
		 * its last argument.
		 */

		/**
		 * There is a primitive root mod <code>m</code>, if and only if <code>m</code> factors into
		 * <code>p<sup>e</sup></code> or <code>2 * p<sup>e</sup></code> where <code>p</code> is an odd prime
		 * number and <code>e</code> is a natural number. Therefore, make sure that <code>2</code> divides
		 * <code>m</code> at most once.
		 */
		long mOddFactor = m;
		if ((mOddFactor & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
			/**
			 * Don't do <code>(mOddFactor &= 1L) == 0L</code> since we need the value of <code>mOddFactor</code>
			 * to remain unchanged. Note that the difference is the <code>&=</code> instead of the
			 * <code>&</code> which will mutate <code>mOddFactor</code>. <br>
			 * <br>
			 * 
			 * However, the following is meant to be an assignment of <code>mOddFactor</code> when we do
			 * <code>mOddFactor /= 2L</code> instead of <code>mOddFactor / 2L</code>.
			 */
			if (((mOddFactor /= 2L) & 1L) == 0L) { // i.e., NumUtil.isEven(mOddFactor)
				return new byte[] {}; // There are no primitive roots mod m since m % 4 == 0.
			}
		}
		// ((m % 2 != 0) && (mOddFactor == m)) || (((m / 2) % 2 != 0) && (mOddFactor == m / 2))

		/**
		 * Factor the largest odd divisor of <code>m</code> and check whether it is a prime power.
		 */
		final Map<Long, Byte> mOddFactors = NumUtil.factorSqrt(mOddFactor, hash, false);
		// Only print if requested.
		if (print) {
			if (m == mOddFactor) {
				System.out.print("m = " + m + " = ");
			} else { // m != mOddFactor
				// i.e., m == 2 * mOddFactor
				System.out.print("m = " + m + " = 2 * ");
			}
			NumUtil.printFactorsLong(mOddFactors, hash);
		}
		if (mOddFactors.size() != 1) {
			return new byte[] {}; // There are no primitive roots mod m since mOddFactor isn't a prime power.
		}

		/**
		 * Compute <code>phi(m)</code> and then factor it. <br>
		 * <br>
		 * 
		 * At this point, we know that one of the following is true: <br>
		 * Case I: <code>m == mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(mOddFactor)</code> <br>
		 * Case II: <code>m == 2 * mOddFactor</code> <br>
		 * Therefore, <code>phi(m) == phi(2) * phi(mOddFactor) == 1 * phi(mOddFactor)</code> <br>
		 * <br>
		 * 
		 * However, we also know that <code>mOddFactor == p<sup>e</sup></code> and so we can conclude that
		 * <code>phi(m) == phi(mOddFactor) == mOddFactor * (1 - <sup>1</sup>&frasl;<sub>p</sub>)</code>.
		 */
		final long p = mOddFactors.entrySet().iterator().next().getKey();
		final long phiM = mOddFactor - (mOddFactor / p);
		final Map<Long, Byte> phiMFactors = NumUtil.factorSqrt(phiM, hash, false);
		// Only print if requested.
		if (print) {
			System.out.print("phi(m) = " + phiM + " = ");
			NumUtil.printFactorsLong(phiMFactors, hash);
		}
		final Set<Long> phiMFactorsKeySet = phiMFactors.keySet();

		/**
		 * Compute <code>phi(phi(m))</code> which is the number of primitive roots mod <code>m</code> using
		 * the following fact: <br>
		 * <br>
		 * 
		 * We know that
		 * <code>phi(n) = product(phi(p<sub>i</sub><sup>e<sub>i</sub></sup>) from i = 1 to i = t)</code>
		 * where <code>p<sub>i</sub></code>'s are the prime factors of <code>n</code> with natural powers
		 * <code>e<sub>i</sub></code> and natural number <code>t</code>. After a little bit of
		 * simplification, we can find that
		 * <code>phi(n) = n * product((1 - <sup>1</sup>&frasl;<sub>p<sub>i</sub></sub>) from i = 1 to i = t)</code>.
		 */
		long phiPhiM = phiM;
		final Iterator<Long> it = phiMFactorsKeySet.iterator();
		do {
			phiPhiM -= (phiPhiM / it.next());
		} while (it.hasNext());

		// Create, fill, and return the resulting byte array.
		final byte[] result = new byte[(int) phiPhiM];
		int index = 0;
		// Save m as a long to avoid the upcast in every iteration of the loop.
		final long M = m, maxN = M - 1L;
		if (M == mOddFactor) { // i.e., m % 2 != 0
			for (long n = 2L; n != maxN; ++n) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, M, phiM, phiMFactorsKeySet)) {
						result[index] = (byte) n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		} else { // i.e., m % 2 == 0
			for (long n = 3L; n != maxN; n += 2L) {
				if (n % p != 0L) { // i.e., gcd(n, m) == 1
					if (AlgebraUtil.isPrimitiveRootFixedInput(n, M, phiM, phiMFactorsKeySet)) {
						result[index] = (byte) n;
						if (++index == result.length) {
							break;
						}
					}
				}
			}
		}
		return result;
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @param hash
	 *            specifies whether the data structure used to store the factors, should be a
	 *            <code>HashMap</code> instead of a <code>TreeMap</code> when factoring <code>m</code>
	 *            and <code>phi(m)</code>
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, hash, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static byte[] primitiveRoots(byte m, boolean hash) throws InvalidModulusException {
		return AlgebraUtil.primitiveRoots(m, hash, false);
	}

	/**
	 * Postcondition: <code>Result != null</code> <br>
	 * Postcondition: <code>(m == 1) implies (Result.length == 0)</code> <br>
	 * Postcondition: <code>(m == 2) implies ((Result.length == 1) && (Result[0] == 1))</code> <br>
	 * Postcondition: <code>(m == 4) implies ((Result.length == 1) && (Result[0] == 3))</code> <br>
	 * Postcondition: <code>(m % 4 == 0) implies ((m != 4) if and only if (Result.length == 0))</code>
	 * <br>
	 * Postcondition:
	 * <code>((m != 2) && (m % 4 != 0)) implies ((NumUtil.factorSqrt((m % 2 == 0) ? (m / 2) : m).size() == 1) if and only if (Result.length != 0))</code>
	 * <br>
	 * Postcondition: <code>(valid i) implies (Result[i] is a primitive root mod m)</code>
	 * 
	 * @param m
	 *            the given modulus
	 * 
	 * @return <code>AlgebraUtil.primitiveRoots(m, false)</code>.
	 * 
	 * @throws InvalidModulusException
	 *             If <code>m <= 0</code>
	 */
	public static byte[] primitiveRoots(byte m) throws InvalidModulusException {
		return AlgebraUtil.primitiveRoots(m, false);
	}
}
